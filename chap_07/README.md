####
## 클래스
####
#### ► [_01_Class_230401]
- 객체를 정의해 객체를 생성하는 데 사용되는 설계도 또는 틀인 클래스 객체 생성 실습
- (1) 객체(object): 속성과 기능의 집합으로 클래스에 정의된 대로 메모리에 생성된 것
- (2) 멤버(member): 객체가 가지고 있는 속성과 기능
- (3) 인스턴스(instance): 클래스로부터 만들어진 객체
- (4) 인스턴스화(instantiate): 클래스로부터 객체를 만드는 과정
- 💡 클래스로부터 객체를 생성하면 클래스에 정의된 속성과 기능을 가진 객체가 만들어진다.  
- 💡 객체는 인스턴스를 대표하는 포괄적 의미를 가지며 인스턴스는 어떤 클래스로부터 만들어졌는지를 강조할 때 사용한다.
- 💡 객체 예시) 랩탑은 객체이다. / 인스턴스 예시) 랩탑은 랩탑 클래스로부터 만들어진 인스턴스다. 
####
#### ► [_02_InstanceVariable_230401]
- 인스턴스마다 별도의 저장공간을 가져 각 인스턴스별로 서로 다른 값을 가질 수 있는 인스턴스 변수 실습
- 💡 인스턴스마다 고유한 상태를 유지해야 하는 속성의 경우, 인스턴스 변수로 선언한다. 
- 💡 인스턴스 변수는 인스턴스를 생성할 때 만들어지므로 값을 읽어오거나 저장하려면 먼저 인스턴스를 생성해야 한다.
####
#### ► [_03_ClassVariable_230401]
- 같은 클래스의 모든 인스턴스가 하나의 저장공간을 가져 공통된 값을 공유하는 클래스 변수 실습
- 💡 한 클래스의 모든 인스턴스가 공통적인 값을 유지해야 하는 속성의 경우, 클래스 변수로 선언한다.
- 💡 클래스 변수는 인스턴스 변수와 달리 인스턴스를 생성하지 않고 언제라도 바로 사용할 수 있다.
- 💡 인스턴스 변수와 구별을 위해 '클래스 이름.클래스 변수'의 형태로 사용하는 것이 적절하다.
####
#### ► [_04_Method_230401]
- 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 메서드 실습
- (1) 매개 변수(parameter): 메서드가 작업을 수행하는 데 필요한 값들
- (2) 인수(argument): 메서드를 호출할 때 괄호 안에 지정해 준 값들
- 💡 메서드를 정의한다는 것은 선언부(반환 타입 ・ 메서드 이름 ・ 매개 변수 선언)와 구현부(수행 문장)를 작성하는 것이다.
####
#### ► [_05_Overloading_230401]
- 클래스 내에 같은 이름의 새로운 메서드를 여러 개 정의하는 오버로딩 실습
- 💡 메서드 이름이 같을 때 매개 변수의 개수 또는 타입이 다르다는 조건을 만족한 경우에 오버로딩이 성립된다.
- 💡 오버로딩을 구현하는데 반환 타입은 아무런 영향을 주지 않는다.
####
#### ► [_06_ClassMethod_230401]
- 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 클래스 메서드 실습
- 💡 클래스 변수와 같이 클래스 메서드 또한 객체를 생성하지 않고도 메서드 호출이 가능하다. 
####
#### ► [_07_This_230401]
- 인스턴스 변수와 매개 변수로 선언된 지역 변수를 구별할 때 사용하는 this 실습
- 💡 참조 변수인 this는 인스턴스 자신을 가리킨다.
- 💡 인스턴스 변수와 매개 변수로 선언된 지역 변수 이름을 다르게 하는 것보다 this로 구별하는 것이 더욱 명확하다.
- 💡 클래스 메서드는 호출 시점에 인스턴스가 존재하지 않을 수 있기 때문에, 인스턴스 변수에 접근하는 this를 사용할 수 없다.
####
#### ► [_08_Constructor_230401]
- 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드인 생성자 실습
- 생성자에서 다른 생성자를 호출하는 생성자 this() 실습
- 💡 생성자의 조건은 생성자 이름이 클래스 이름과 같고 반환값이 없다는 조건을 만족해야 한다.
- 💡 생성자는 주로 인스턴스 변수 초기화 작업에 사용되며 인스턴스 생성 시 실행되어야 하는 작업을 위해 사용된다.
- 💡 생성자는 메서드의 구조와 유사하게 클래스 내에 선언되지만. 모든 생성자가 반환값이 없다는 점(void 생략)에서 차이가 있다.
- 💡 생성자도 오버로딩이 가능하며 하나의 클래스에 여러 개의 생성자가 존재할 수 있다.
####
#### ► [_09_GetterAndSetter_230401]
- 멤버 변수의 값을 읽어 반환하는 메서드 getter 실습
- 매개 변수에 지정된 값을 검사하여 조건에 맞는 값일 때만 멤버 변수의 값을 변경하는 메서드 setter 실습
- 💡 접근 제어자로 보호할 멤버 변수의 접근을 제한하고, public 메서드를 제공해 간접적으로 멤버 변수의 값을 다룰 수 있도록 한다. 
- 💡 getter는 'get멤버 변수 이름'으로, setter는'set멤버 변수 이름'으로 메서드 이름을 정의하는 것이 적절하다.
####
#### ► [_10_AccessModifier_230402]
- 클래스 ・ 멤버 변수 ・ 메서드 ・ 생성자에서 외부 접근을 제한하는 접근 제어자 실습
- (1) private: 같은 클래스 내에서만 접근 가능
- (2) (default): 같은 패키지 내에서만 접근 가능
- (3) protected: 같은 패키지와 다른 패키지의 자손 클래스에서 접근 가능
- (4) public: 접근 제한 없음
- 💡 접근 제어자를 사용하는 이유는 외부로부터 데이터를 보호하고, 불필요하거나 또는 내부적으로 사용되는 부분을 감추기 위함이다.
- 💡 접근 제어자가 지정되어 있지 않다면 default로 이해하며, default는 아무런 접근 제어자가 붙지 않음을 의미한다.
####
#### ► [_11_Package_230402]
- 클래스의 묶음인 패키지 중, 난수를 생성하는 Random 클래스 실습
- 소스 파일에 사용된 클래스의 패키지에 대한 정보를 컴파일러에 제공하는 import문 실습
- 💡 패키지 이름은 클래스 이름과 쉽게 구분하기 위해 소문자로 지정하는 것이 적절하다.
- 💡 클래스의 실제 이름은 패키지명을 포함하므로, 같은 이름의 클래스일지라도 서로 다른 패키지에서 존재할 수 있다.
- 💡 패키지 선언문은 반드시 소스 파일에서 주석과 공백을 제외한 첫 번째 문장에 위치해야 한다.
- 💡 속할 패키지를 지정하지 않은 클래스는 자동으로 이름 없는 패키지(unnamed package)에 속하게 된다.
- 💡 import문은 패키지문 다음과 클래스 선언문 이전에 위치해야 하며, 하나의 소스 파일에 중복으로 선언할 수 있다.
####
#### ► [_12_Inheritance_230402]
- 기존 클래스를 재사용하여 새로운 클래스를 작성하는 상속 실습
- 💡 상속 키워드가 'extends'인 이유는 상속받는다는 것이 조상 클래스를 확장(extend)한다는 의미로 해석할 수 있기 때문이다.
- 💡 상속은 코드의 재사용성을 높이고 중복을 제거하여 프로그램의 생산성과 유지보수에 기여한다. 
- 💡 자손 클래스는 조상 클래스의 모든 멤버와 메서드를 상속받으며, 생성자와 초기화 블럭은 상속되지 않는다. 
- 💡 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
####
#### ► [_13_Overriding_230402]
- 조상 클래스로부터 상속받은 메서드의 내용을 자손 클래스에 맞게 변경하는 오버라이딩 실습
- 💡 선언부(메서드 이름, 매개 변수, 반환 타입)는 조상 클래스의 메서드와 일치해야 한다.
- 💡 접근 제어자를 조상 클래스의 메서드보다 좁은 범위(public → protected → (default) → private)로 변경할 수 없다.
- 💡 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
####
#### ► [_14_Polymorphism_230402]
-
####
#### ► [_15_Super_230403]
-
####
#### ► [_16_Reference_230403]
-
####
